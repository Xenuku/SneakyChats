
# Sneaky Chats

This was a project for University built with Angular, MongoDB, Node and Sockets. Security was not a concern for this project so passwords are not safely stored nor is there significant sanitisation for user input. Commit history was lost due to the removal of my repository, this is a new upload.

## Screenshots

![Chat Screen](images/chat.png?raw=true "Chat")

![Admin Home](images/admin_home.png?raw=true" "Admin Home")

![Admin Management](images/admin_user.png?raw=true" "Admin User Management")


## Data structures

### Client
- **Users**: 
Users is an object with nested arrays of objects that have nested arrays. The nested array of objects are the groups the user is in which hold what role the user is within that group, and the nested arrays within those objects are the channels the user has access to. 
**Example**:
```js
{ 
	_id: ObjectID("Generated by MongoDB"),
	username: "Super",
	password: "securepassword",
	email: "username@domain.com",
	level: "superadmin",
	groups: [
		{
			group: "Programmers",
			role: "member",
			channels: ["JavaScript", "Python"]
			
		},
		{
			group: "Hobby",
			role: "Moderator",
			channels: []
		}
	]
}
```


- **Groups**: 
Group is an object with a nested array of channels.
**Example**:
```js
{
	_id: ObjectID("Generated by MongoDB"),
	group: "Programmers",
	channels: ["JavaScript", "Python", "C++"]
}
```
### Server
Most data-structures follow the same structure as the client, as the data is stored in MongoDB. The only difference is the history for each room which is handled entirely serverside.
- **History**
History is stored in a separate database, and a collection is made per unique group. Each collection contains an objects per message.
**Example**:
```js
{
	_id: ObjectID("Generated by MongoDB"),
	room: "Channel_Name",
	username: "UserThatSentMessage",
	text: "UsersMessage",
	time: "TimeUserSentMessage"
}
```

## Angular Architecture
- A simple chat component with all chat logic included inside it, including socket integration the chat is accessed via /chat.

- The manage component which imports several child components such as channelmanager, groupmanager, moderatorpanel, and usermanager. These components all make up one page, but are compartmentalised for readabilty. This is accessed by those with appropriate permissions via /manage.

- The account component includes a form for the user to update their information and picture, it is accessed via /account.

- The login component is the 'front page' and the first page a user is greeted with if they are not logged in, it is also where a user is redirected to if they are not logged in and try to access a 'protected page'

- I use a service that allows me to update whether or not the user has logged in/out for the menu to display the appropriate 'manage' button if required. Without this service using observables, if an admin logged in they would not see a manage button until they refreshed the page. 

## Node Server Architecture

The main server.js imports the socket.js that holds the main socket functions, such as group listings, emitting or broadcasting chat/connection/room change/leave messages alongside the history fetching for each room.
Functions for cleaning up the users chat messages, getting channels that belong to the user, handling the changes of rooms and if a user has left etc are all handled by a separate module called 'chat.js' under functions. Another module that handles connecting to the database is used in 'db.js' under the functions folder as well. Both export to the main server.js to be utilised throughout the server.

The routes for various database functions are separated into a 'routes' folder, each containing relevant functions and data processing depending on which route is being accessed. Eg: Authentication under auth.js, user related querying under user.js, group related querying under group.js and channel functions under channel.js.


## Responsibility division

The server is responsible for handling all socket processing, and querying the database to emit or send information back. It is also responsible for some error checking (if a group already exists, if a user already exists, if a user tries to change their name to an existing name, wrong username/password, etc). The server is also capable of serving the static built files from Angular using 'ng build'. 

The client is responsible for almost everything else, including logic checking for role access, error handling and validations. 

## Listings

My API could use some work, this was my first time creating an API and in the future I will work harder to build a cleaner API.

#### Users
<table>
	<th>Route</th>
	<th>Parameter</th>	
	<th>Return Values/Purpose</th>
  <tr>
    <td>/api/users/</td>
    <td>None</td>
    <td>Get: Return all users as array of objects <br> Post: Insert new user, return message of success/failure</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>:username</td>
    <td> Get: Return specific user as an object <br> Put: Update specific user, return message of success/failure <br> Delete: Delete specific user, return message of success/failure</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>:username/:group</td>
    <td>Put: On group creation, add to the current groupadmins groups (default owner)</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>:username/level</td>
    <td>Put: SuperAdmin/GroupAdmin update a users level</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>upload/:username</td>
    <td>Put: Upload the users profile picture</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>group/:group</td>
    <td>Get: Get all users within a specific group as an object/array of objects</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>:username/:group</td>
    <td>Put: Updates a users access to groups, roles and channels</td>
  </tr>
  <tr>
    <td>/api/users/</td>
    <td>:username/:group/mod</td>
    <td>Put: Updates a users access to channels, MOD only</td>
  </tr>
</table>

**As seen from listings, a refactor is needed of the user routes to condense them.**

#### Auth
<table>
	<th>Route</th>
	<th>Parameter</th>	
	<th>Return Values/Purpose</th>
  <tr>
    <td>/api/auth/</td>
    <td>None</td>
    <td>Post: Logs the user in, returns data from user to be stored</td>
  </tr>
</table>

#### Groups
<table>
	<th>Route</th>
	<th>Parameter</th>	
	<th>Return Values/Purpose</th>
  <tr>
    <td>/api/groups/</td>
    <td>None</td>
    <td>Get: Gets all groups an array of objects <br> Post: Adds a new group</td>
  </tr>
  <tr>
    <td>/api/groups/</td>
    <td>:group</td>
    <td>Get: Gets the specified group as an object <br> Delete: Deletes a group from database, user data and history</td>
  </tr>
</table>

#### Channels
<table>
	<th>Route</th>
	<th>Parameter</th>	
	<th>Return Values/Purpose</th>
  <tr>
    <td>/api/channels/</td>
    <td>:group</td>
    <td>Get: Gets all the channels for a group <br> Put: Adds or deletes a channel in a group</td>
  </tr>
  <tr>
    <td>/api/channels/</td>
    <td>:group/mod</td>
    <td>Put: Adds channels to group that a moderator is in </td>
  </tr>
</table>



## Interactions

Client displays front end login page, server is ready for connections.
User fills in log in form, server checks the database and verify the user exists and then if the user is using a valid password. If both pass, the user is sent a response and the front-end stores the values returned by the server in the users local storage for quick access. If either fail, the user is sent a message that displays under the login form telling them what went wrong.

After login, the user is taken to the chat room page where the server processes the connection to the socket and emits the users rooms that they have access to after querying the database and emits that they joined the server/room to other users. If the user sends a message, it emits it to the server, the server then adds the message to the database for the room the user is in and then emits the users message back to all connected clients. The same goes for if a user chooses an image to send, it simply emits the image back to all clients. The messages are pushed to a message array and displayed on the screen using two way binding. If a user leaves the room or navigates pages, appropriate messages are broadcast to all users in that room via the server.

On the account page, the user may fill out a form to update their account information. The server processes this information and returns a result if it failed (due to username conflict) or succeeded. A user may also change their profile picture by clicking the image and uploading a new one, the server processes this and stores it directly into the database and the client stores it as a localStorage item for quick viewing.

If the user is either a superadmin, group_admin as their 'level' or a 'moderator' in one of the groups they are in, the user may access the 'Manage' page. Moderators may only access the moderator panel, whereas the other two roles have multiple options available to them. The client handles most of this, the server provides a list of all users and a list of all groups when the user clicks 'manage'. The user may fill out various forms to process actions to the server, the server updates/deletes/adds to the database as required and returns a response to the users client.

